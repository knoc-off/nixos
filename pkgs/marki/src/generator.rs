use crate::card::{Card, NoteType};
use crate::highlighter;
use anyhow::{Context, Result};
use genanki_rs::{Deck, Field, Model, ModelType, Note, Package, Template, cloze_model};
use std::collections::HashMap;
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::path::Path;

fn generate_id(name: &str) -> i64 {
    let mut hasher = DefaultHasher::new();
    name.hash(&mut hasher);
    (hasher.finish() & 0x7FFFFFFF) as i64
}

fn generate_card_guid(file_path: &str) -> String {
    let path = Path::new(file_path);

    let filename = path.file_name().and_then(|n| n.to_str()).unwrap(); // should never happen

    let parent_dir = path
        .parent()
        .and_then(|p| p.file_name())
        .and_then(|n| n.to_str())
        .unwrap_or("default");

    let combined = format!("{}/{}", parent_dir, filename);

    let mut hasher = DefaultHasher::new();
    combined.hash(&mut hasher);
    let hash = hasher.finish();

    // Anki GUID, hex-string
    format!("{:016x}", hash)
}

fn create_basic_model() -> Model {
    dbg!("Creating basic card model");

    let css = format!(
        r#"
.card {{
    font-family: Arial, sans-serif;
    font-size: 20px;
    text-align: left;
    color: black;
    background-color: white;
}}

.code {{
    background-color: #2b303b;
    color: #c0c5ce;
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto;
}}

{}
"#,
        highlighter::generate_css()
    );

    Model::new(
        generate_id("marki-basic-model"),
        "Marki Basic",
        vec![
            Field::new("Front"),
            Field::new("Back"),
            Field::new("Source"),
        ],
        vec![
            Template::new("Card 1")
                .qfmt("{{Front}}")
                .afmt(r#"{{FrontSide}}<hr id="answer">{{Back}}"#),
        ],
    )
    .css(&css)
}

fn create_cloze_model() -> Model {
    dbg!("Creating cloze card model");

    let css = format!(
        r#"
.card {{
    font-family: Arial, sans-serif;
    font-size: 20px;
    text-align: left;
    color: black;
    background-color: white;
}}

.cloze {{
    font-weight: bold;
    color: blue;
}}

.code {{
    background-color: #2b303b;
    color: #c0c5ce;
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto;
}}

{}
"#,
        highlighter::generate_css()
    );

    Model::new_with_options(
        generate_id("marki-cloze-model"),
        "Marki Cloze",
        vec![
            Field::new("Text"),
            Field::new("Extra"),
            Field::new("Source"),
        ],
        vec![
            Template::new("Cloze")
                .qfmt("{{cloze:Text}}")
                .afmt("{{cloze:Text}}<br>{{Extra}}"),
        ],
        Some(&css),
        Some(ModelType::Cloze),
        None, // latex_pre
        None, // latex_post
        None, // sort_field_index
    )
}

pub fn generate_decks(
    decks_cards: HashMap<String, Vec<Card>>,
    output_path: &Path,
    media_files: Vec<String>,
) -> Result<()> {
    dbg!("Generating multiple decks", decks_cards.len());

    let basic_model = create_basic_model();
    let cloze_model = create_cloze_model();

    let mut all_decks = Vec::new();

    for (deck_name, cards) in decks_cards {
        dbg!("Creating deck", &deck_name, cards.len());

        let deck_id = generate_id(&deck_name);
        let mut deck = Deck::new(deck_id, &deck_name, "Generated by marki");

        for (idx, card) in cards.iter().enumerate() {
            // dbg!("Processing card", idx, &card.note_type, &card.tags);

            let guid = card
                .file_path
                .as_ref()
                .map(|p| generate_card_guid(p))
                .unwrap_or_else(|| format!("{:016x}", idx));

            // dbg!("Generated GUID for card", &guid, &card.file_path);

            let model = match card.note_type {
                NoteType::Cloze => {
                    dbg!("Creating cloze note", card.front.len(), card.back.len());
                    &cloze_model
                }
                NoteType::Basic => {
                    dbg!("Creating basic note", card.front.len(), card.back.len());
                    &basic_model
                }
            };

            let note = Note::new(
                model.clone(),
                vec![&card.front, &card.back, &card.source_markdown],
            )
            .context(format!("Failed to create note for card {}", idx))?
            .guid(&guid);

            // dbg!("Tags for card", &card.tags);

            deck.add_note(note);
        }

        all_decks.push(deck);
    }

    dbg!("Writing package to file", output_path, all_decks.len());

    let media_refs: Vec<&str> = media_files.iter().map(|s| s.as_str()).collect();
    let mut package = Package::new(all_decks, media_refs).context("Failed to create package")?;
    package
        .write_to_file(output_path.to_str().unwrap())
        .context("Failed to write package to file")?;

    dbg!("Successfully wrote package");
    Ok(())
}
