use crate::card::{Card, NoteType};
use crate::highlighter;
use anyhow::{Context, Result};
use genanki_rs::{Deck, Field, Model, Note, Template};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::path::Path;

/// Generate a stable ID from a string
fn generate_id(name: &str) -> i64 {
    let mut hasher = DefaultHasher::new();
    name.hash(&mut hasher);
    (hasher.finish() & 0x7FFFFFFF) as i64
}

/// Create a basic card model (front/back)
fn create_basic_model() -> Model {
    dbg!("Creating basic card model");

    let css = format!(
        r#"
.card {{
    font-family: Arial, sans-serif;
    font-size: 20px;
    text-align: left;
    color: black;
    background-color: white;
}}

.code {{
    background-color: #2b303b;
    color: #c0c5ce;
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto;
}}

{}
"#,
        highlighter::generate_css()
    );

    Model::new(
        generate_id("marki-basic-model"),
        "Marki Basic",
        vec![Field::new("Front"), Field::new("Back")],
        vec![Template::new("Card 1")
            .qfmt("{{Front}}")
            .afmt(r#"{{FrontSide}}<hr id="answer">{{Back}}"#)],
    )
    .css(&css)
}

/// Create a cloze card model
fn create_cloze_model() -> Model {
    dbg!("Creating cloze card model");

    let css = format!(
        r#"
.card {{
    font-family: Arial, sans-serif;
    font-size: 20px;
    text-align: left;
    color: black;
    background-color: white;
}}

.cloze {{
    font-weight: bold;
    color: blue;
}}

.code {{
    background-color: #2b303b;
    color: #c0c5ce;
    padding: 10px;
    border-radius: 5px;
    overflow-x: auto;
}}

{}
"#,
        highlighter::generate_css()
    );

    // Create a cloze model using new_with_options
    // Parameters: id, name, fields, templates, css, latex_pre, latex_post, sort_field, req
    Model::new_with_options(
        generate_id("marki-cloze-model"),
        "Marki Cloze",
        vec![Field::new("Text"), Field::new("Extra")],
        vec![Template::new("Cloze")
            .qfmt("{{cloze:Text}}")
            .afmt("{{cloze:Text}}<br>{{Extra}}")],
        Some(&css),
        None,        // latex_pre
        None,        // latex_post
        None,        // sort_field
        None,        // req
    )
}

/// Generate an Anki deck from cards
pub fn generate_deck(
    cards: Vec<Card>,
    deck_name: &str,
    output_path: &Path,
) -> Result<()> {
    dbg!("Generating deck", deck_name, cards.len());

    let deck_id = generate_id(deck_name);
    let mut deck = Deck::new(deck_id, deck_name, "Generated by marki");

    let basic_model = create_basic_model();
    let cloze_model = create_cloze_model();

    for (idx, card) in cards.iter().enumerate() {
        dbg!("Processing card", idx, &card.note_type, &card.tags);

        match card.note_type {
            NoteType::Cloze => {
                // Cloze card - front contains cloze deletions, back is extra context
                dbg!("Creating cloze note", card.front.len(), card.back.len());
                let note = Note::new(
                    cloze_model.clone(),
                    vec![&card.front, &card.back],
                )
                .context(format!("Failed to create cloze note for card {}", idx))?;

                // TODO: Add tag support when genanki-rs supports it
                // Tags: {:?}
                dbg!("Tags for cloze card", &card.tags);

                deck.add_note(note);
            }
            NoteType::Basic => {
                // Basic card - front/back split by first ---
                dbg!("Creating basic note", card.front.len(), card.back.len());
                let note = Note::new(
                    basic_model.clone(),
                    vec![&card.front, &card.back],
                )
                .context(format!("Failed to create basic note for card {}", idx))?;

                // TODO: Add tag support when genanki-rs supports it
                // Tags: {:?}
                dbg!("Tags for basic card", &card.tags);

                deck.add_note(note);
            }
        }
    }

    dbg!("Writing deck to file", output_path);
    deck.write_to_file(output_path.to_str().unwrap())
        .context("Failed to write deck to file")?;

    dbg!("Successfully wrote deck");
    Ok(())
}
